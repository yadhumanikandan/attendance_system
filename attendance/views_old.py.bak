import pandas as pd
import os
from datetime import timedelta
from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.http import HttpResponseForbidden
from .models import Employee, AttendanceRecord, ShiftHistory, Holiday


def superuser_required(user):
    """Check if user is a superuser."""
    return user.is_superuser


@login_required
@user_passes_test(superuser_required, login_url='/report/')
def upload_file(request):
    if request.method == 'POST' and request.FILES['file']:
        excel_file = request.FILES['file']
        selected_date_str = request.POST.get('date')
        
        if not selected_date_str:
            messages.error(request, 'Please select a date.')
            return redirect('upload')

        # Determine engine based on extension
        filename = excel_file.name
        _, ext = os.path.splitext(filename)
        engine = "xlrd" if ext == ".xls" else "openpyxl"

        try:
            df = pd.read_excel(excel_file, engine=engine)

            # Replace '-' with NaN
            df.replace("-", pd.NA, inplace=True)

            # Combine Selected Date + Time columns
            # We use the selected date instead of the date in the file
            df["First-In"] = pd.to_datetime(
                selected_date_str + " " + df["First-In"].astype(str),
                errors="coerce"
            )

            df["Last-Out"] = pd.to_datetime(
                selected_date_str + " " + df["Last-Out"].astype(str),
                errors="coerce"
            )

            grouped = df.groupby(["Person ID", "Name"])

            for (person_id, name), group in grouped:
                # Get or create employee by ID + Name combo
                employee, created = Employee.objects.get_or_create(
                    person_id=person_id,
                    name=name
                )

                first_in = group["First-In"].min()
                last_out = group["Last-Out"].max()

                if pd.isna(first_in) or pd.isna(last_out):
                    duration = timedelta(0)
                    fi_time = None
                    lo_time = None
                    # Use selected date even if times are missing
                    date_val = pd.to_datetime(selected_date_str).date()
                else:
                    duration = last_out - first_in
                    fi_time = first_in.time()
                    lo_time = last_out.time()
                    date_val = first_in.date()

                # Create or Update AttendanceRecord for this employee and date
                AttendanceRecord.objects.update_or_create(
                    employee=employee,
                    date=date_val,
                    defaults={
                        'first_in': fi_time,
                        'last_out': lo_time,
                        'work_duration': duration
                    }
                )

            messages.success(request, 'File uploaded and processed successfully!')
            return redirect('report')

        except Exception as e:
            messages.error(request, f'Error processing file: {str(e)}')
            return redirect('upload')

    return render(request, 'attendance/upload.html')

@login_required
def attendance_report(request):
    import datetime
    import calendar
    from datetime import time
    from django.db.models import Prefetch

    # Get current date
    now = datetime.datetime.now()
    
    # Get filter params or default to current
    try:
        selected_month = int(request.GET.get('month', now.month))
        selected_year = int(request.GET.get('year', now.year))
    except ValueError:
        selected_month = now.month
        selected_year = now.year

    # Filter records
    records_qs = AttendanceRecord.objects.filter(
        date__year=selected_year, 
        date__month=selected_month
    ).order_by('date')

    # Check if we should show inactive employees
    show_inactive = request.GET.get('show_inactive', '') == '1'
    
    # Get search query
    search_query = request.GET.get('search', '').strip()
    
    # Fetch employees with filtered records
    employees_qs = Employee.objects.prefetch_related(
        Prefetch('attendancerecord_set', queryset=records_qs, to_attr='filtered_records')
    )
    
    # Filter by active status unless show_inactive is checked
    if not show_inactive:
        employees_qs = employees_qs.filter(is_active=True)
    
    # Filter by search query if provided
    if search_query:
        employees_qs = employees_qs.filter(name__icontains=search_query)
    
    employees = employees_qs.order_by('name')

    # Calendar data - calculate first so days_in_month is available
    first_weekday, days_in_month = calendar.monthrange(selected_year, selected_month)
    # first_weekday: 0=Monday, 6=Sunday. We want Sunday as first column (index 0)
    # Convert: Monday=0 -> Sunday-based: Monday=1, Tuesday=2, ..., Sunday=0
    first_weekday_sunday = (first_weekday + 1) % 7

    # Build list of day numbers for calendar grid (1-based) with None for empty cells
    calendar_days = [None] * first_weekday_sunday + list(range(1, days_in_month + 1))
    # Pad to complete the last week
    while len(calendar_days) % 7 != 0:
        calendar_days.append(None)

    # Add status to each record and create calendar data
    from .models import MonthlySummary
    import datetime as dt
    
    # Calculate Sundays in month (holidays) and Saturdays
    sundays_in_month = 0
    saturdays_in_month = 0
    
    # Determine the end day for calculation (today if current month, else last day of month)
    today = dt.date.today()
    if selected_year == today.year and selected_month == today.month:
        calculation_end_day = today.day
    elif (selected_year < today.year) or (selected_year == today.year and selected_month < today.month):
        calculation_end_day = days_in_month
    else:
        calculation_end_day = 0  # Future month
    
    # Query custom holidays for this month
    month_start = dt.date(selected_year, selected_month, 1)
    month_end = dt.date(selected_year, selected_month, days_in_month)
    holidays_in_month = Holiday.objects.filter(date__gte=month_start, date__lte=month_end)
    holiday_dates = set(h.date for h in holidays_in_month)
    holiday_names = {h.date: h.name for h in holidays_in_month}
    
    # Calculate Sundays and custom holidays up to the calculation end day
    sundays_until_now = 0
    holidays_until_now = 0
    for day in range(1, calculation_end_day + 1):
        date = dt.date(selected_year, selected_month, day)
        if date.weekday() == 6:  # Sunday
            sundays_until_now += 1
        elif date in holiday_dates:  # Custom holiday (not Sunday)
            holidays_until_now += 1
    
    # Total holidays = Sundays + custom holidays
    total_holidays_until_now = sundays_until_now + holidays_until_now
    
    # Expected working days = days passed so far - Sundays passed so far - holidays
    expected_working_days = calculation_end_day - sundays_until_now - holidays_until_now
    
    # Pass current day for template to hide future days
    current_day = today.day if selected_year == today.year and selected_month == today.month else 32  # 32 means all days shown if past month
    
    for employee in employees:
        # Create a dict: day -> record data
        employee.calendar_data = {}
        late_count = 0
        half_day_count = 0
        
        # Track actual working days (non-zero hours, non-Sunday)
        actual_working_days_count = 0
        
        # Get employee's shift timings for the selected month
        # Look up the most recent shift history entry that was effective before/during this month
        import datetime as dt
        month_start = dt.date(selected_year, selected_month, 1)
        
        applicable_shift = ShiftHistory.objects.filter(
            employee=employee,
            effective_from__lte=month_start
        ).order_by('-effective_from').first()
        
        if applicable_shift:
            # Use the shift from history
            emp_shift_start = applicable_shift.shift_start
            emp_shift_end = applicable_shift.shift_end
        elif employee.shift_start and employee.shift_end:
            # Fallback to employee's default shift
            emp_shift_start = employee.shift_start
            emp_shift_end = employee.shift_end
        else:
            # Ultimate fallback: 10:00-19:00
            emp_shift_start = time(10, 0)
            emp_shift_end = time(19, 0)
        
        # Calculate expected work hours based on shift timings
        shift_duration_weekday = (
            (emp_shift_end.hour * 60 + emp_shift_end.minute) - 
            (emp_shift_start.hour * 60 + emp_shift_start.minute)
        ) * 60  # in seconds
        
        # Saturday shift: same start time but 4 hours duration
        sat_shift_end = time(emp_shift_start.hour + 4, emp_shift_start.minute)

        # Convert filtered records to a dict for easy lookup
        records_dict = {r.date.day: r for r in employee.filtered_records}
        
        # Iterate through ALL days of the month to populate calendar data
        for day in range(1, days_in_month + 1):
            date_obj = datetime.date(selected_year, selected_month, day)
            weekday = date_obj.weekday()  # 0=Mon, 6=Sun
            is_sunday = weekday == 6
            is_saturday = weekday == 5
            is_holiday_date = date_obj in holiday_dates
            
            record = records_dict.get(day)
            
            # Initialize variables
            status = 'absent'
            is_half_day = False
            is_late = False
            
            # Logic for determining status
            if is_sunday:
                status = 'holiday'
            elif is_holiday_date:
                status = 'holiday'
            elif record:
                # Same logic as before for record processing
                total_secs = record.work_duration.total_seconds() if record.work_duration else 0
                
                # Count actual working days (exclude Sundays and zero-hour records)
                if total_secs > 0 and not is_sunday:
                    actual_working_days_count += 1
                
                # Check arrival time - after 12:00 means half day
                arrived_after_noon = record.first_in and record.first_in.hour >= 12
                
                # Different rules for Saturday vs weekdays
                if is_saturday:  # Saturday: employee's shift_start + 4 hours
                    hours_ok = total_secs >= 14400
                    time_in_ok = record.first_in and (
                        record.first_in.hour < emp_shift_start.hour or 
                        (record.first_in.hour == emp_shift_start.hour and record.first_in.minute <= emp_shift_start.minute)
                    )
                    time_out_ok = record.last_out and (
                        record.last_out.hour > sat_shift_end.hour or 
                        (record.last_out.hour == sat_shift_end.hour and record.last_out.minute >= sat_shift_end.minute)
                    )
                else:  # Weekdays
                    hours_ok = total_secs >= shift_duration_weekday
                    time_in_ok = record.first_in and (
                        record.first_in.hour < emp_shift_start.hour or 
                        (record.first_in.hour == emp_shift_start.hour and record.first_in.minute <= emp_shift_start.minute)
                    )
                    time_out_ok = record.last_out and (
                        record.last_out.hour > emp_shift_end.hour or 
                        (record.last_out.hour == emp_shift_end.hour and record.last_out.minute >= emp_shift_end.minute)
                    )
                
                # Count late arrivals (not Sunday)
                if not is_sunday and record.first_in and not time_in_ok and not arrived_after_noon:
                    late_count += 1
                    is_late = True
                
                # Determine half day
                if not is_sunday and total_secs > 0:
                    if arrived_after_noon:
                        is_half_day = True
                    elif not time_out_ok:
                        is_half_day = True
                
                if is_half_day:
                    half_day_count += 1
                
                # Determine status
                if total_secs == 0:
                    status = 'absent'
                elif is_half_day:
                    status = 'yellow'
                elif hours_ok and time_in_ok and time_out_ok:
                    status = 'green'
                else:
                    status = 'yellow'
            else:
                # No record
                if day > current_day:
                    # Future day
                    status = 'future' # Or leave it to template to handle?
                    # Actually, if we set status='future', template can use it.
                    # Or keep 'absent' but ensure template knows it's future?
                    # The template checks `if day > current_day`.
                    pass
                else:
                    status = 'absent'

            employee.calendar_data[day] = {
                'record': record,
                'status': status,
                'is_sunday': is_sunday,
                'is_saturday': is_saturday,
                'is_half_day': is_half_day,
                'is_late': is_late,
                'is_holiday': is_holiday_date,
            }
        
        # Calculate summary stats
        # Full days = working days - half days
        full_days = actual_working_days_count - half_day_count
        if full_days < 0:
            full_days = 0
        
        # Leave days = expected working days - actual working days (exclude Sundays from calculation)
        leave_days = expected_working_days - actual_working_days_count
        if leave_days < 0:
            leave_days = 0  # In case they worked on Sundays too
        
        # Store in employee for template access
        # Total working = full days + (half days * 0.5) + Sundays + custom holidays
        total_working = full_days + (half_day_count * 0.5) + total_holidays_until_now
        
        employee.summary = {
            'working_days': actual_working_days_count,
            'full_days': full_days,
            'half_days': half_day_count,
            'total_working': total_working,
            'sundays': sundays_until_now,
            'holidays': holidays_until_now,
            'leave_days': leave_days,
            'late_days': late_count,
        }
        
        # Save to database
        MonthlySummary.objects.update_or_create(
            employee=employee,
            year=selected_year,
            month=selected_month,
            defaults={
                'working_days': actual_working_days_count,
                'leave_days': leave_days,
                'late_days': late_count,
                'half_days': half_day_count,
            }
        )


    # Get pending early leave requests for admin view
    from .models import EarlyLeaveRequest
    pending_requests = EarlyLeaveRequest.objects.filter(status='pending').select_related('employee', 'remote_employee')
    pending_count = pending_requests.count()

    context = {
        'employees': employees,
        'selected_month': selected_month,
        'selected_year': selected_year,
        'current_day': current_day,
        'months': [
            (1, 'January'), (2, 'February'), (3, 'March'), (4, 'April'),
            (5, 'May'), (6, 'June'), (7, 'July'), (8, 'August'),
            (9, 'September'), (10, 'October'), (11, 'November'), (12, 'December')
        ],
        'years': range(2020, 2036),  # Extended to 2035
        'calendar_days': calendar_days,
        'weekdays': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        'days_in_month': days_in_month,
        'show_inactive': show_inactive,
        'search_query': search_query,
        'holiday_days': [h.date.day for h in holidays_in_month],  # List of day numbers that are holidays
        'holiday_names': {h.date.day: h.name for h in holidays_in_month},  # Map day number to name
        'pending_requests': pending_requests,
        'pending_count': pending_count,
    }
    return render(request, 'attendance/report.html', context)


@login_required
def download_report(request):
    """Generate and download XLSX report for the selected month."""
    import datetime
    import calendar
    from django.http import HttpResponse
    from openpyxl import Workbook
    from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
    from openpyxl.utils import get_column_letter
    
    # Get filter params
    now = datetime.datetime.now()
    try:
        selected_month = int(request.GET.get('month', now.month))
        selected_year = int(request.GET.get('year', now.year))
    except ValueError:
        selected_month = now.month
        selected_year = now.year
    
    # Get month name
    month_names = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                   'July', 'August', 'September', 'October', 'November', 'December']
    month_name = month_names[selected_month]
    
    # Calculate Sundays in the month
    _, days_in_month = calendar.monthrange(selected_year, selected_month)
    sundays_count = 0
    for day in range(1, days_in_month + 1):
        date = datetime.date(selected_year, selected_month, day)
        if date.weekday() == 6:  # Sunday
            sundays_count += 1
    
    # Check if we should include inactive employees
    show_inactive = request.GET.get('show_inactive', '') == '1'
    
    # Get employees with their monthly summaries
    from .models import MonthlySummary
    
    summaries = MonthlySummary.objects.filter(
        year=selected_year,
        month=selected_month
    ).select_related('employee')
    
    if not show_inactive:
        summaries = summaries.filter(employee__is_active=True)
    
    summaries = summaries.order_by('employee__name')
    
    # Create workbook
    wb = Workbook()
    ws = wb.active
    ws.title = f"{month_name} {selected_year}"
    
    # Styles
    title_font = Font(bold=True, size=14)
    header_font = Font(bold=True, size=11)
    header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
    header_font_white = Font(bold=True, size=11, color="FFFFFF")
    thin_border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Title row
    ws.merge_cells('A1:G1')
    ws['A1'] = f"Attendance Report - {month_name} {selected_year}"
    ws['A1'].font = title_font
    ws['A1'].alignment = Alignment(horizontal='center')
    
    # Empty row
    ws.append([])
    
    # Get holidays for the month
    holidays_in_month = Holiday.objects.filter(
        date__year=selected_year,
        date__month=selected_month
    ).count()
    total_holidays = sundays_count + holidays_in_month
    
    # Header row - Updated columns
    headers = ['Employee Name', 'Full Days', 'Half Days', 'Leave Days', 'Late Arrivals', 'Holidays', 'Working Days']
    ws.append(headers)
    
    # Style headers
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=3, column=col)
        cell.font = header_font_white
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal='center')
        cell.border = thin_border
    
    # Data rows
    for summary in summaries:
        # Get half days from summary
        half_days = getattr(summary, 'half_days', 0) or 0
        
        # Full Days = working_days - half_days (since working_days includes both full and half)
        full_days = max(0, summary.working_days - half_days)
        
        # Leave Days
        leave_days = summary.leave_days
        
        # Working Days = Full Days + (Half Days * 0.5) + Holidays
        working_days_total = full_days + (half_days * 0.5) + total_holidays
        
        row = [
            summary.employee.name,
            full_days,
            half_days,
            leave_days,
            summary.late_days,
            total_holidays,
            working_days_total
        ]
        ws.append(row)
        
        # Apply border to data cells
        current_row = ws.max_row
        for col in range(1, 8):
            cell = ws.cell(row=current_row, column=col)
            cell.border = thin_border
            if col > 1:  # Center numeric columns
                cell.alignment = Alignment(horizontal='center')
    
    # Adjust column widths
    ws.column_dimensions['A'].width = 30  # Employee Name
    ws.column_dimensions['B'].width = 12  # Full Days
    ws.column_dimensions['C'].width = 12  # Half Days
    ws.column_dimensions['D'].width = 12  # Leave Days
    ws.column_dimensions['E'].width = 14  # Late Arrivals
    ws.column_dimensions['F'].width = 12  # Holidays
    ws.column_dimensions['G'].width = 14  # Working Days
    
    # Create response with proper file handling
    from io import BytesIO
    buffer = BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    response = HttpResponse(
        buffer.getvalue(),
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    filename = f"Attendance_Report_{selected_year}_{selected_month:02d}.xlsx"
    response['Content-Disposition'] = f'attachment; filename={filename}'
    response['Content-Length'] = len(buffer.getvalue())
    
    return response


@login_required
def download_employee_report(request, employee_id):
    """Generate and download XLSX report for a single employee for the selected month."""
    import datetime
    import calendar
    from datetime import time
    from django.http import HttpResponse
    from django.shortcuts import get_object_or_404
    from openpyxl import Workbook
    from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
    from openpyxl.utils import get_column_letter
    
    # Get employee
    employee = get_object_or_404(Employee, id=employee_id)
    
    # Get filter params
    now = datetime.datetime.now()
    try:
        selected_month = int(request.GET.get('month', now.month))
        selected_year = int(request.GET.get('year', now.year))
    except ValueError:
        selected_month = now.month
        selected_year = now.year
    
    # Get month name
    month_names = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                   'July', 'August', 'September', 'October', 'November', 'December']
    month_name = month_names[selected_month]
    
    # Get holidays for the month
    holiday_dates = set(Holiday.objects.filter(
        date__year=selected_year,
        date__month=selected_month
    ).values_list('date', flat=True))
    
    # Get attendance records for the employee
    records = AttendanceRecord.objects.filter(
        employee=employee,
        date__year=selected_year,
        date__month=selected_month
    ).order_by('date')
    
    # Create a dictionary for quick lookup
    records_dict = {r.date: r for r in records}
    
    # Create workbook
    wb = Workbook()
    ws = wb.active
    ws.title = f"{employee.name[:20]}"  # Sheet name limit
    
    # Styles
    title_font = Font(bold=True, size=14)
    header_font = Font(bold=True, size=11)
    header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
    header_font_white = Font(bold=True, size=11, color="FFFFFF")
    holiday_fill = PatternFill(start_color="E9D5FF", end_color="E9D5FF", fill_type="solid")
    sunday_fill = PatternFill(start_color="E9D5FF", end_color="E9D5FF", fill_type="solid")
    green_fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
    yellow_fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
    red_fill = PatternFill(start_color="FECACA", end_color="FECACA", fill_type="solid")
    thin_border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Title rows
    ws.merge_cells('A1:F1')
    ws['A1'] = f"Attendance Report - {month_name} {selected_year}"
    ws['A1'].font = title_font
    ws['A1'].alignment = Alignment(horizontal='center')
    
    ws.merge_cells('A2:F2')
    ws['A2'] = f"Employee: {employee.name} (ID: {employee.person_id})"
    ws['A2'].font = Font(bold=True, size=12)
    ws['A2'].alignment = Alignment(horizontal='center')
    
    # Empty row
    ws.append([])
    
    # Header row
    headers = ['Date', 'Day', 'First In', 'Last Out', 'Duration', 'Status']
    ws.append(headers)
    
    # Style headers
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=4, column=col)
        cell.font = header_font_white
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal='center')
        cell.border = thin_border
    
    # Calculate days in month
    _, days_in_month = calendar.monthrange(selected_year, selected_month)
    
    # Summary counters
    full_days = 0
    half_days = 0
    leave_days = 0
    late_arrivals = 0
    holidays_count = 0
    
    # Get shift timings
    applicable_shift = ShiftHistory.objects.filter(
        employee=employee,
        effective_from__lte=datetime.date(selected_year, selected_month, 1)
    ).order_by('-effective_from').first()
    
    if applicable_shift:
        emp_shift_start = applicable_shift.shift_start
        emp_shift_end = applicable_shift.shift_end
    elif employee.shift_start and employee.shift_end:
        emp_shift_start = employee.shift_start
        emp_shift_end = employee.shift_end
    else:
        emp_shift_start = time(10, 0)
        emp_shift_end = time(19, 0)
    
    # Data rows
    day_names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    for day in range(1, days_in_month + 1):
        date = datetime.date(selected_year, selected_month, day)
        weekday = date.weekday()
        day_name = day_names[weekday]
        is_sunday = weekday == 6
        is_holiday = date in holiday_dates
        is_saturday = weekday == 5
        
        record = records_dict.get(date)
        
        if is_sunday or is_holiday:
            holidays_count += 1
            status = "Holiday"
            first_in = "-"
            last_out = "-"
            duration = "-"
            fill = sunday_fill if is_sunday else holiday_fill
        elif record:
            first_in = record.first_in.strftime("%H:%M") if record.first_in else "-"
            last_out = record.last_out.strftime("%H:%M") if record.last_out else "-"
            duration = str(record.work_duration) if record.work_duration else "-"
            
            # Calculate status
            total_secs = record.work_duration.total_seconds() if record.work_duration else 0
            is_late = record.first_in and record.first_in > emp_shift_start
            arrived_after_noon = record.first_in and record.first_in.hour >= 12
            
            # Check for early departure - Saturday has different end time (start + 4 hours)
            if is_saturday:
                # Saturday: shift ends 4 hours after start
                sat_shift_end = time(emp_shift_start.hour + 4, emp_shift_start.minute)
                left_early = record.last_out and (
                    record.last_out.hour < sat_shift_end.hour or 
                    (record.last_out.hour == sat_shift_end.hour and record.last_out.minute < sat_shift_end.minute)
                )
            else:
                # Regular weekday: use full shift end time
                left_early = record.last_out and (
                    record.last_out.hour < emp_shift_end.hour or 
                    (record.last_out.hour == emp_shift_end.hour and record.last_out.minute < emp_shift_end.minute)
                )
            
            # Determine half day status
            is_half_day = arrived_after_noon or left_early
            
            if total_secs == 0:
                status = "Leave"
                fill = red_fill
                leave_days += 1
            elif is_half_day:
                status = "Half Day"
                fill = yellow_fill
                half_days += 1
                if is_late:
                    late_arrivals += 1
            elif is_late:
                status = "Late"
                fill = yellow_fill
                full_days += 1
                late_arrivals += 1
            else:
                status = "Present"
                fill = green_fill
                full_days += 1
        else:
            first_in = "-"
            last_out = "-"
            duration = "-"
            # Only count as leave if it's a past day
            if date <= datetime.date.today():
                status = "Leave"
                fill = red_fill
                leave_days += 1
            else:
                status = "-"
                fill = None
        
        row = [
            date.strftime("%Y-%m-%d"),
            day_name,
            first_in,
            last_out,
            duration,
            status
        ]
        ws.append(row)
        
        # Apply styles to data row
        current_row = ws.max_row
        for col in range(1, 7):
            cell = ws.cell(row=current_row, column=col)
            cell.border = thin_border
            cell.alignment = Alignment(horizontal='center')
            if fill:
                cell.fill = fill
    
    # Empty row before summary
    ws.append([])
    ws.append([])
    
    # Summary section
    summary_row = ws.max_row + 1
    ws.merge_cells(f'A{summary_row}:F{summary_row}')
    ws.cell(row=summary_row, column=1).value = "Monthly Summary"
    ws.cell(row=summary_row, column=1).font = title_font
    ws.cell(row=summary_row, column=1).alignment = Alignment(horizontal='center')
    
    summary_data = [
        ("Full Days", full_days),
        ("Half Days", half_days),
        ("Leave Days", leave_days),
        ("Late Arrivals", late_arrivals),
        ("Holidays/Sundays", holidays_count),
        ("Working Days", full_days + (half_days * 0.5) + holidays_count)
    ]
    
    for label, value in summary_data:
        ws.append([label, value])
        current_row = ws.max_row
        ws.cell(row=current_row, column=1).font = Font(bold=True)
        ws.cell(row=current_row, column=1).border = thin_border
        ws.cell(row=current_row, column=2).border = thin_border
        ws.cell(row=current_row, column=2).alignment = Alignment(horizontal='center')
    
    # Adjust column widths
    ws.column_dimensions['A'].width = 14  # Date
    ws.column_dimensions['B'].width = 8   # Day
    ws.column_dimensions['C'].width = 10  # First In
    ws.column_dimensions['D'].width = 10  # Last Out
    ws.column_dimensions['E'].width = 12  # Duration
    ws.column_dimensions['F'].width = 12  # Status
    
    # Create response
    from io import BytesIO
    buffer = BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    response = HttpResponse(
        buffer.getvalue(),
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    # Sanitize employee name for filename
    safe_name = "".join(c for c in employee.name if c.isalnum() or c in (' ', '-', '_')).strip()
    safe_name = safe_name.replace(' ', '_')
    filename = f"{safe_name}_Attendance_{selected_year}_{selected_month:02d}.xlsx"
    response['Content-Disposition'] = f'attachment; filename={filename}'
    response['Content-Length'] = len(buffer.getvalue())
    
    return response


# ============================================
# Remote Team Views
# ============================================

def parse_duration(duration_str):
    """Parse duration string like 'HH:MM:SS' to timedelta."""
    if not duration_str or duration_str == '':
        return timedelta(0)
    try:
        parts = str(duration_str).split(':')
        if len(parts) == 3:
            hours, minutes, seconds = map(int, parts)
            return timedelta(hours=hours, minutes=minutes, seconds=seconds)
        elif len(parts) == 2:
            minutes, seconds = map(int, parts)
            return timedelta(minutes=minutes, seconds=seconds)
    except (ValueError, AttributeError):
        pass
    return timedelta(0)


@login_required
@user_passes_test(superuser_required, login_url='/report/')
def upload_remote_call_stats(request):
    """Handle CSV upload for remote team call statistics."""
    from .models import RemoteEmployee, RemoteCallRecord
    
    if request.method == 'POST' and request.FILES.get('remote_file'):
        csv_file = request.FILES['remote_file']
        selected_date_str = request.POST.get('remote_date')
        
        if not selected_date_str:
            messages.error(request, 'Please select a date for remote call statistics.')
            return redirect('upload')
        
        try:
            # Read CSV file
            df = pd.read_csv(csv_file)
            
            # Parse the selected date
            selected_date = pd.to_datetime(selected_date_str).date()
            
            processed_count = 0
            for _, row in df.iterrows():
                extension_col = row.get('Extension', '')
                
                # Skip Total row
                if str(extension_col).strip().lower() == 'total':
                    continue
                
                # Parse extension: "3068-Maria"
                if '-' in str(extension_col):
                    parts = str(extension_col).split('-', 1)
                    extension_id = parts[0].strip()
                    name = parts[1].strip() if len(parts) > 1 else 'Unknown'
                else:
                    continue  # Skip invalid rows
                
                # Get or create remote employee
                employee, created = RemoteEmployee.objects.get_or_create(
                    extension_id=extension_id,
                    name=name
                )
                
                # Parse call statistics
                answered = int(row.get('Answered', 0) or 0)
                no_answered = int(row.get('No Answered', 0) or 0)
                busy = int(row.get('Busy', 0) or 0)
                failed = int(row.get('Failed', 0) or 0)
                voicemail = int(row.get('Voicemail', 0) or 0)
                
                # Parse durations
                ring_duration = parse_duration(row.get('Total Ring Duration', ''))
                talk_duration = parse_duration(row.get('Total Talk Duration', ''))
                
                # Create or update call record (attendance status calculated in save())
                RemoteCallRecord.objects.update_or_create(
                    employee=employee,
                    date=selected_date,
                    defaults={
                        'answered_calls': answered,
                        'no_answered': no_answered,
                        'busy': busy,
                        'failed': failed,
                        'voicemail': voicemail,
                        'total_ring_duration': ring_duration,
                        'total_talk_duration': talk_duration,
                    }
                )
                processed_count += 1
            
            messages.success(request, f'Remote call statistics uploaded! Processed {processed_count} employees.')
            return redirect('remote_report')
            
        except Exception as e:
            messages.error(request, f'Error processing remote file: {str(e)}')
            return redirect('upload')
    
    return redirect('upload')


@login_required
def remote_attendance_report(request):
    """Display attendance report for remote team."""
    import datetime
    import calendar
    from django.db.models import Prefetch
    from .models import RemoteEmployee, RemoteCallRecord, RemoteMonthlySummary
    
    # Get current date
    now = datetime.datetime.now()
    
    # Get filter params or default to current
    try:
        selected_month = int(request.GET.get('month', now.month))
        selected_year = int(request.GET.get('year', now.year))
    except ValueError:
        selected_month = now.month
        selected_year = now.year
    
    # Filter records
    records_qs = RemoteCallRecord.objects.filter(
        date__year=selected_year,
        date__month=selected_month
    ).order_by('date')
    
    # Check if we should show inactive employees
    show_inactive = request.GET.get('show_inactive', '') == '1'
    
    # Get search query
    search_query = request.GET.get('search', '').strip()
    
    # Fetch employees with filtered records
    employees_qs = RemoteEmployee.objects.prefetch_related(
        Prefetch('remotecallrecord_set', queryset=records_qs, to_attr='filtered_records')
    )
    
    # Filter by active status unless show_inactive is checked
    if not show_inactive:
        employees_qs = employees_qs.filter(is_active=True)
    
    # Filter by search query if provided
    if search_query:
        employees_qs = employees_qs.filter(name__icontains=search_query)
    
    employees = employees_qs.order_by('name')
    
    # Calendar data
    first_weekday, days_in_month = calendar.monthrange(selected_year, selected_month)
    first_weekday_sunday = (first_weekday + 1) % 7
    
    calendar_days = [None] * first_weekday_sunday + list(range(1, days_in_month + 1))
    while len(calendar_days) % 7 != 0:
        calendar_days.append(None)
    
    # Calculate expected working days (excluding Sundays)
    import datetime as dt
    today = dt.date.today()
    if selected_year == today.year and selected_month == today.month:
        calculation_end_day = today.day
    elif (selected_year < today.year) or (selected_year == today.year and selected_month < today.month):
        calculation_end_day = days_in_month
    else:
        calculation_end_day = 0
    
    # Query custom holidays for this month
    month_start = dt.date(selected_year, selected_month, 1)
    month_end = dt.date(selected_year, selected_month, days_in_month)
    holidays_in_month = Holiday.objects.filter(date__gte=month_start, date__lte=month_end)
    holiday_dates = set(h.date for h in holidays_in_month)
    
    # Calculate Sundays and custom holidays up to the calculation end day
    sundays_until_now = 0
    holidays_until_now = 0
    for day in range(1, calculation_end_day + 1):
        date = dt.date(selected_year, selected_month, day)
        if date.weekday() == 6:
            sundays_until_now += 1
        elif date in holiday_dates:  # Custom holiday (not Sunday)
            holidays_until_now += 1
    
    total_holidays_until_now = sundays_until_now + holidays_until_now
    expected_working_days = calculation_end_day - sundays_until_now - holidays_until_now
    current_day = today.day if selected_year == today.year and selected_month == today.month else 32
    
    # Process each employee
    for employee in employees:
        employee.calendar_data = {}
        present_count = 0
        half_day_count = 0
        absent_count = 0
        total_talk_seconds = 0
        
        # Convert filtered records to a dict for easy lookup
        records_dict = {r.date.day: r for r in employee.filtered_records}
        
        # Iterate through ALL days of the month to populate calendar data
        for day in range(1, days_in_month + 1):
            date_obj = datetime.date(selected_year, selected_month, day)
            weekday = date_obj.weekday()  # 0=Mon, 6=Sun
            is_sunday = weekday == 6
            is_saturday = weekday == 5
            is_holiday_date = date_obj in holiday_dates
            
            record = records_dict.get(day)
            
            # Initialize variables
            status = 'absent' # Default to absent for past days without records
            talk_minutes = 0
            answered_calls = 0
            
            if is_sunday:
                status = 'holiday'
            elif is_holiday_date:
                status = 'holiday'
            elif record:
                # Get talk duration in minutes for display
                if record.total_talk_duration:
                    talk_minutes = int(record.total_talk_duration.total_seconds() / 60)
                    total_talk_seconds += record.total_talk_duration.total_seconds()
                
                answered_calls = record.answered_calls
                status = record.attendance_status
                
                # Count attendance
                if not is_sunday:
                    if record.attendance_status == 'present':
                        present_count += 1
                    elif record.attendance_status == 'half_day':
                        half_day_count += 1
                    else:
                        pass # Absent count calculated later or here?
                        # Wait, logic below calculates absent days based on total - records.
                        # I should keep that logic or adapt it.
                        # Existing logic used `absent_count += 1` inside loop if record present but status=absent.
                        # AND `total_absent` calculation at line 1055.
                        
                    if record.attendance_status == 'absent':
                        absent_count += 1
            else:
                 # No record
                 if day > current_day:
                     status = 'future' # Or 'absent' but handled by template?
                     # I'll stick to 'absent' but template handles future.
                     # Or better: set status='future' if supported.
                     # Let's use 'absent' standard and let template check future.
                     status = 'absent'
                 else:
                     status = 'absent'
            
            employee.calendar_data[day] = {
                'record': record,
                'status': status,
                'is_sunday': is_sunday,
                'is_saturday': is_saturday,
                'is_holiday': is_holiday_date,
                'talk_minutes': talk_minutes,
                'answered_calls': answered_calls,
            }
        
        # Calculate absent days (days without records)
        days_with_records = len([r for r in employee.filtered_records if r.date.weekday() != 6])
        total_absent = expected_working_days - days_with_records - present_count - half_day_count
        if total_absent < 0:
            total_absent = 0
        absent_count += total_absent
        
        employee.summary = {
            'present_days': present_count,
            'half_days': half_day_count,
            'absent_days': absent_count,
            'total_talk_hours': round(total_talk_seconds / 3600, 1),
        }
        
        # Save monthly summary
        RemoteMonthlySummary.objects.update_or_create(
            employee=employee,
            year=selected_year,
            month=selected_month,
            defaults={
                'present_days': present_count,
                'half_days': half_day_count,
                'absent_days': absent_count,
                'total_talk_time': timedelta(seconds=total_talk_seconds),
            }
        )
    
    context = {
        'employees': employees,
        'selected_month': selected_month,
        'selected_year': selected_year,
        'current_day': current_day,
        'months': [
            (1, 'January'), (2, 'February'), (3, 'March'), (4, 'April'),
            (5, 'May'), (6, 'June'), (7, 'July'), (8, 'August'),
            (9, 'September'), (10, 'October'), (11, 'November'), (12, 'December')
        ],
        'years': range(2020, 2036),
        'calendar_days': calendar_days,
        'weekdays': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        'days_in_month': days_in_month,
        'show_inactive': show_inactive,
        'search_query': search_query,
        'holiday_days': [h.date.day for h in holidays_in_month],
        'holiday_names': {h.date.day: h.name for h in holidays_in_month},
    }
    return render(request, 'attendance/remote_report.html', context)


@login_required
def download_remote_report(request):
    """Generate and download XLSX report for remote team."""
    import datetime
    import calendar
    from django.http import HttpResponse
    from openpyxl import Workbook
    from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
    from .models import RemoteMonthlySummary
    
    # Get filter params
    now = datetime.datetime.now()
    try:
        selected_month = int(request.GET.get('month', now.month))
        selected_year = int(request.GET.get('year', now.year))
    except ValueError:
        selected_month = now.month
        selected_year = now.year
    
    month_names = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                   'July', 'August', 'September', 'October', 'November', 'December']
    month_name = month_names[selected_month]
    
    # Calculate Sundays in the month
    _, days_in_month = calendar.monthrange(selected_year, selected_month)
    sundays_count = 0
    for day in range(1, days_in_month + 1):
        date = datetime.date(selected_year, selected_month, day)
        if date.weekday() == 6:  # Sunday
            sundays_count += 1
    
    show_inactive = request.GET.get('show_inactive', '') == '1'
    
    summaries = RemoteMonthlySummary.objects.filter(
        year=selected_year,
        month=selected_month
    ).select_related('employee')
    
    if not show_inactive:
        summaries = summaries.filter(employee__is_active=True)
    
    summaries = summaries.order_by('employee__name')
    
    # Create workbook
    wb = Workbook()
    ws = wb.active
    ws.title = f"{month_name} {selected_year}"
    
    # Styles
    title_font = Font(bold=True, size=14)
    header_fill = PatternFill(start_color="8B5CF6", end_color="8B5CF6", fill_type="solid")  # Purple for remote
    header_font_white = Font(bold=True, size=11, color="FFFFFF")
    thin_border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Title row
    ws.merge_cells('A1:E1')
    ws['A1'] = f"Remote Team Attendance Report - {month_name} {selected_year}"
    ws['A1'].font = title_font
    ws['A1'].alignment = Alignment(horizontal='center')
    
    ws.append([])
    
    # Get holidays for the month
    holidays_in_month = Holiday.objects.filter(
        date__year=selected_year,
        date__month=selected_month
    ).count()
    total_holidays = sundays_count + holidays_in_month
    
    # Header row - Updated columns with Holidays and Working Days
    headers = ['Employee Name', 'Full Days', 'Half Days', 'Leave Days', 'Holidays', 'Working Days']
    ws.append(headers)
    
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=3, column=col)
        cell.font = header_font_white
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal='center')
        cell.border = thin_border
    
    # Data rows
    for summary in summaries:
        # Get half days from summary
        half_days = summary.half_days
        
        # Full Days = present days - half days
        full_days = max(0, summary.present_days - half_days)
        
        # Leave Days = absent days
        leave_days = summary.absent_days
        
        # Working Days = Full Days + (Half Days * 0.5) + Holidays
        working_days_total = full_days + (half_days * 0.5) + total_holidays
        
        row = [
            summary.employee.name,
            full_days,
            half_days,
            leave_days,
            total_holidays,
            working_days_total
        ]
        ws.append(row)
        
        current_row = ws.max_row
        for col in range(1, 7):
            cell = ws.cell(row=current_row, column=col)
            cell.border = thin_border
            if col > 1:
                cell.alignment = Alignment(horizontal='center')
    
    # Column widths
    ws.column_dimensions['A'].width = 30  # Employee Name
    ws.column_dimensions['B'].width = 12  # Full Days
    ws.column_dimensions['C'].width = 12  # Half Days
    ws.column_dimensions['D'].width = 12  # Leave Days
    ws.column_dimensions['E'].width = 12  # Holidays
    ws.column_dimensions['F'].width = 14  # Working Days
    
    # Create response with proper file handling
    from io import BytesIO
    buffer = BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    response = HttpResponse(
        buffer.getvalue(),
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    filename = f"Remote_Attendance_Report_{selected_year}_{selected_month:02d}.xlsx"
    response['Content-Disposition'] = f'attachment; filename={filename}'
    response['Content-Length'] = len(buffer.getvalue())
    
    return response


@login_required
def download_remote_employee_report(request, employee_id):
    """Generate and download XLSX report for a single remote employee for the selected month."""
    import datetime
    import calendar
    from django.http import HttpResponse
    from django.shortcuts import get_object_or_404
    from openpyxl import Workbook
    from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
    from .models import RemoteEmployee, RemoteCallRecord
    
    # Get employee
    employee = get_object_or_404(RemoteEmployee, id=employee_id)
    
    # Get filter params
    now = datetime.datetime.now()
    try:
        selected_month = int(request.GET.get('month', now.month))
        selected_year = int(request.GET.get('year', now.year))
    except ValueError:
        selected_month = now.month
        selected_year = now.year
    
    # Get month name
    month_names = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                   'July', 'August', 'September', 'October', 'November', 'December']
    month_name = month_names[selected_month]
    
    # Get holidays for the month
    holiday_dates = set(Holiday.objects.filter(
        date__year=selected_year,
        date__month=selected_month
    ).values_list('date', flat=True))
    
    # Get call records for the employee
    records = RemoteCallRecord.objects.filter(
        employee=employee,
        date__year=selected_year,
        date__month=selected_month
    ).order_by('date')
    
    # Create a dictionary for quick lookup
    records_dict = {r.date: r for r in records}
    
    # Create workbook
    wb = Workbook()
    ws = wb.active
    ws.title = f"{employee.name[:20]}"  # Sheet name limit
    
    # Styles
    title_font = Font(bold=True, size=14)
    header_font = Font(bold=True, size=11)
    header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
    header_font_white = Font(bold=True, size=11, color="FFFFFF")
    holiday_fill = PatternFill(start_color="E9D5FF", end_color="E9D5FF", fill_type="solid")
    green_fill = PatternFill(start_color="D1FAE5", end_color="D1FAE5", fill_type="solid")
    yellow_fill = PatternFill(start_color="FEF3C7", end_color="FEF3C7", fill_type="solid")
    red_fill = PatternFill(start_color="FECACA", end_color="FECACA", fill_type="solid")
    thin_border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Title rows
    ws.merge_cells('A1:F1')
    ws['A1'] = f"Remote Call Statistics - {month_name} {selected_year}"
    ws['A1'].font = title_font
    ws['A1'].alignment = Alignment(horizontal='center')
    
    ws.merge_cells('A2:F2')
    ws['A2'] = f"Employee: {employee.name} (Extension: {employee.extension_id})"
    ws['A2'].font = Font(bold=True, size=12)
    ws['A2'].alignment = Alignment(horizontal='center')
    
    # Empty row
    ws.append([])
    
    # Header row
    headers = ['Date', 'Day', 'Answered Calls', 'Talk Duration', 'Status']
    ws.append(headers)
    
    # Style headers
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=4, column=col)
        cell.font = header_font_white
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal='center')
        cell.border = thin_border
    
    # Calculate days in month
    _, days_in_month = calendar.monthrange(selected_year, selected_month)
    
    # Summary counters
    present_days = 0
    half_days = 0
    absent_days = 0
    holidays_count = 0
    total_calls = 0
    total_talk_minutes = 0
    
    # Data rows
    day_names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    for day in range(1, days_in_month + 1):
        date = datetime.date(selected_year, selected_month, day)
        weekday = date.weekday()
        day_name = day_names[weekday]
        is_sunday = weekday == 6
        is_holiday = date in holiday_dates
        
        record = records_dict.get(date)
        
        if is_sunday or is_holiday:
            holidays_count += 1
            status = "Holiday"
            answered_calls = "-"
            talk_duration = "-"
            fill = holiday_fill
        elif record:
            answered_calls = record.answered_calls or 0
            talk_minutes = int(record.total_talk_duration.total_seconds() / 60) if record.total_talk_duration else 0
            talk_duration = f"{talk_minutes} min"
            total_calls += answered_calls
            total_talk_minutes += talk_minutes
            
            if record.attendance_status == 'present':
                status = "Present"
                fill = green_fill
                present_days += 1
            elif record.attendance_status == 'half_day':
                status = "Half Day"
                fill = yellow_fill
                half_days += 1
            else:
                status = "Absent"
                fill = red_fill
                absent_days += 1
        else:
            answered_calls = "-"
            talk_duration = "-"
            # Only count as absent if it's a past day
            if date <= datetime.date.today():
                status = "No Data"
                fill = red_fill
                absent_days += 1
            else:
                status = "-"
                fill = None
        
        row = [
            date.strftime("%Y-%m-%d"),
            day_name,
            answered_calls,
            talk_duration,
            status
        ]
        ws.append(row)
        
        # Apply styles to data row
        current_row = ws.max_row
        for col in range(1, 6):
            cell = ws.cell(row=current_row, column=col)
            cell.border = thin_border
            cell.alignment = Alignment(horizontal='center')
            if fill:
                cell.fill = fill
    
    # Empty row before summary
    ws.append([])
    ws.append([])
    
    # Summary section
    summary_row = ws.max_row + 1
    ws.merge_cells(f'A{summary_row}:E{summary_row}')
    ws.cell(row=summary_row, column=1).value = "Monthly Summary"
    ws.cell(row=summary_row, column=1).font = title_font
    ws.cell(row=summary_row, column=1).alignment = Alignment(horizontal='center')
    
    summary_data = [
        ("Present Days", present_days),
        ("Half Days", half_days),
        ("Absent Days", absent_days),
        ("Holidays/Sundays", holidays_count),
        ("Total Calls Answered", total_calls),
        ("Total Talk Time", f"{total_talk_minutes} min"),
        ("Working Days", present_days + (half_days * 0.5) + holidays_count)
    ]
    
    for label, value in summary_data:
        ws.append([label, value])
        current_row = ws.max_row
        ws.cell(row=current_row, column=1).font = Font(bold=True)
        ws.cell(row=current_row, column=1).border = thin_border
        ws.cell(row=current_row, column=2).border = thin_border
        ws.cell(row=current_row, column=2).alignment = Alignment(horizontal='center')
    
    # Adjust column widths
    ws.column_dimensions['A'].width = 14  # Date
    ws.column_dimensions['B'].width = 8   # Day
    ws.column_dimensions['C'].width = 15  # Answered Calls
    ws.column_dimensions['D'].width = 15  # Talk Duration
    ws.column_dimensions['E'].width = 12  # Status
    
    # Create response
    from io import BytesIO
    buffer = BytesIO()
    wb.save(buffer)
    buffer.seek(0)
    
    response = HttpResponse(
        buffer.getvalue(),
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    # Sanitize employee name for filename
    safe_name = "".join(c for c in employee.name if c.isalnum() or c in (' ', '-', '_')).strip()
    safe_name = safe_name.replace(' ', '_')
    filename = f"{safe_name}_Remote_Stats_{selected_year}_{selected_month:02d}.xlsx"
    response['Content-Disposition'] = f'attachment; filename={filename}'
    response['Content-Length'] = len(buffer.getvalue())
    
    return response


# ============================================
# API Endpoints
# ============================================

@login_required
def update_attendance(request):
    """API endpoint to update attendance records. Super admin only."""
    import json
    from datetime import datetime, timedelta
    from django.http import JsonResponse
    from .models import Employee, AttendanceRecord, MonthlySummary
    
    # Only super admins can edit attendance
    if not request.user.is_superuser:
        return JsonResponse({'error': 'Permission denied. Super admin access required.'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Only POST method allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        employee_id = data.get('employee_id')
        date_str = data.get('date')  # Format: YYYY-MM-DD
        first_in = data.get('first_in')  # Format: HH:MM
        last_out = data.get('last_out')  # Format: HH:MM
        
        if not all([employee_id, date_str]):
            return JsonResponse({'error': 'Missing required fields: employee_id, date'}, status=400)
        
        # Parse date
        record_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        
        # Get employee
        try:
            employee = Employee.objects.get(id=employee_id)
        except Employee.DoesNotExist:
            return JsonResponse({'error': 'Employee not found'}, status=404)
        
        # Parse times
        first_in_time = None
        last_out_time = None
        work_duration = None
        
        if first_in:
            first_in_time = datetime.strptime(first_in, '%H:%M').time()
        if last_out:
            last_out_time = datetime.strptime(last_out, '%H:%M').time()
        
        # Calculate work duration
        if first_in_time and last_out_time:
            first_dt = datetime.combine(record_date, first_in_time)
            last_dt = datetime.combine(record_date, last_out_time)
            if last_dt > first_dt:
                work_duration = last_dt - first_dt
            else:
                work_duration = timedelta(0)
        
        # Create or update attendance record
        record, created = AttendanceRecord.objects.update_or_create(
            employee=employee,
            date=record_date,
            defaults={
                'first_in': first_in_time,
                'last_out': last_out_time,
                'work_duration': work_duration
            }
        )
        
        # Recalculate monthly summary
        recalculate_monthly_summary(employee, record_date.year, record_date.month)
        
        return JsonResponse({
            'success': True,
            'message': 'Attendance updated successfully',
            'data': {
                'employee_id': employee.id,
                'date': date_str,
                'first_in': first_in,
                'last_out': last_out,
                'work_duration': str(work_duration) if work_duration else None
            }
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON data'}, status=400)
    except ValueError as e:
        return JsonResponse({'error': f'Invalid data format: {str(e)}'}, status=400)
    except Exception as e:
        return JsonResponse({'error': f'Server error: {str(e)}'}, status=500)


def recalculate_monthly_summary(employee, year, month):
    """Recalculate monthly summary for an employee after attendance edit."""
    import calendar
    from .models import AttendanceRecord, MonthlySummary, ShiftHistory
    from datetime import time
    
    # Get all records for the month
    records = AttendanceRecord.objects.filter(
        employee=employee,
        date__year=year,
        date__month=month
    )
    
    # Get employee shift timings (default 10:00-19:00)
    default_shift_start = time(10, 0)
    default_shift_end = time(19, 0)
    shift_start = employee.shift_start or default_shift_start
    shift_end = employee.shift_end or default_shift_end
    
    # Count attendance metrics
    working_days = records.count()
    late_days = 0
    early_departure_days = 0
    
    for record in records:
        if record.first_in and record.first_in > shift_start:
            late_days += 1
        if record.last_out and record.last_out < shift_end:
            early_departure_days += 1
    
    # Calculate leave days (workdays minus working_days)
    first_day, days_in_month = calendar.monthrange(year, month)
    # Count weekdays (Mon-Sat, assuming Sunday is off)
    total_workdays = 0
    for day in range(1, days_in_month + 1):
        from datetime import date
        d = date(year, month, day)
        if d.weekday() != 6:  # Not Sunday
            total_workdays += 1
    
    leave_days = max(0, total_workdays - working_days)
    
    # Update or create summary
    MonthlySummary.objects.update_or_create(
        employee=employee,
        year=year,
        month=month,
        defaults={
            'working_days': working_days,
            'leave_days': leave_days,
            'late_days': late_days,
            'early_departure_days': early_departure_days
        }
    )


# ============================================
# Employee Self-Service Portal
# ============================================

def employee_login(request):
    """Login page for employee portal (separate from admin login)."""
    from django.contrib.auth.hashers import check_password, make_password
    from .models import Employee, RemoteEmployee
    
    # If already logged in as employee, redirect to portal
    if request.session.get('employee_id'):
        return redirect('employee_portal')
    
    error_message = None
    
    if request.method == 'POST':
        email = request.POST.get('email', '').strip().lower()
        password = request.POST.get('password', '')
        
        if not email or not password:
            error_message = "Please enter both email and password."
        else:
            # Try to find employee by email (check both models)
            employee = None
            employee_type = None
            
            # Check in-house employees
            try:
                emp = Employee.objects.get(email__iexact=email, is_active=True)
                if emp.portal_password:
                    if check_password(password, emp.portal_password):
                        employee = emp
                        employee_type = 'inhouse'
            except Employee.DoesNotExist:
                pass
            except Employee.MultipleObjectsReturned:
                emp = Employee.objects.filter(email__iexact=email, is_active=True).first()
                if emp and emp.portal_password and check_password(password, emp.portal_password):
                    employee = emp
                    employee_type = 'inhouse'
            
            # If not found, check remote employees
            if not employee:
                try:
                    remote_emp = RemoteEmployee.objects.get(email__iexact=email, is_active=True)
                    if remote_emp.portal_password:
                        if check_password(password, remote_emp.portal_password):
                            employee = remote_emp
                            employee_type = 'remote'
                except RemoteEmployee.DoesNotExist:
                    pass
                except RemoteEmployee.MultipleObjectsReturned:
                    remote_emp = RemoteEmployee.objects.filter(email__iexact=email, is_active=True).first()
                    if remote_emp and remote_emp.portal_password and check_password(password, remote_emp.portal_password):
                        employee = remote_emp
                        employee_type = 'remote'
            
            if employee:
                # Store in session
                request.session['employee_id'] = employee.id
                request.session['employee_type'] = employee_type
                request.session['employee_name'] = employee.name
                return redirect('employee_portal')
            else:
                error_message = "Invalid email or password."
    
    return render(request, 'attendance/employee_login.html', {'error_message': error_message})


def employee_logout(request):
    """Logout from employee portal."""
    # Clear employee session data
    if 'employee_id' in request.session:
        del request.session['employee_id']
    if 'employee_type' in request.session:
        del request.session['employee_type']
    if 'employee_name' in request.session:
        del request.session['employee_name']
    return redirect('employee_login')


def employee_portal(request):
    """Employee portal - shows only the logged-in employee's attendance calendar."""
    import datetime
    import calendar
    from .models import Employee, AttendanceRecord, RemoteEmployee, RemoteCallRecord, Holiday
    
    # Check if employee is logged in via session
    employee_id = request.session.get('employee_id')
    employee_type = request.session.get('employee_type')
    employee_name = request.session.get('employee_name')
    
    if not employee_id or not employee_type:
        return redirect('employee_login')
    
    # Get current date
    now = datetime.datetime.now()
    
    # Get filter params or default to current
    try:
        selected_month = int(request.GET.get('month', now.month))
        selected_year = int(request.GET.get('year', now.year))
    except ValueError:
        selected_month = now.month
        selected_year = now.year
    
    # Get calendar data
    first_weekday, days_in_month = calendar.monthrange(selected_year, selected_month)
    first_weekday_sunday = (first_weekday + 1) % 7
    
    calendar_days = [None] * first_weekday_sunday + list(range(1, days_in_month + 1))
    while len(calendar_days) % 7 != 0:
        calendar_days.append(None)
    
    # Get holidays for the month
    month_start = datetime.date(selected_year, selected_month, 1)
    month_end = datetime.date(selected_year, selected_month, days_in_month)
    holidays_in_month = Holiday.objects.filter(date__gte=month_start, date__lte=month_end)
    holiday_dates = set(h.date for h in holidays_in_month)
    holiday_days = [h.date.day for h in holidays_in_month]
    
    today = datetime.date.today()
    current_day = today.day if selected_year == today.year and selected_month == today.month else 32
    
    # Month names for header
    month_names = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                   'July', 'August', 'September', 'October', 'November', 'December']
    
    if employee_type == 'inhouse':
        # Get in-house employee and their attendance records
        try:
            employee = Employee.objects.get(id=employee_id)
        except Employee.DoesNotExist:
            return redirect('employee_logout')
        
        records = AttendanceRecord.objects.filter(
            employee=employee,
            date__year=selected_year,
            date__month=selected_month
        )
        records_dict = {r.date.day: r for r in records}
        
        # Get shift timings
        default_shift_start = datetime.time(10, 0)
        default_shift_end = datetime.time(19, 0)
        shift_start = employee.shift_start or default_shift_start
        shift_end = employee.shift_end or default_shift_end
        
        # Build calendar data
        calendar_data = {}
        summary = {'full_days': 0, 'leave_days': 0, 'late_days': 0, 'half_days': 0, 'holidays': 0}
        
        for day in range(1, days_in_month + 1):
            date = datetime.date(selected_year, selected_month, day)
            weekday = date.weekday()
            is_sunday = weekday == 6
            is_holiday = date in holiday_dates
            
            # Only count holidays up to current day
            if (is_sunday or is_holiday) and day <= current_day:
                summary['holidays'] += 1
            
            record = records_dict.get(day)
            
            if is_sunday or is_holiday:
                calendar_data[day] = {
                    'record': None,
                    'status': 'holiday',
                    'is_sunday': is_sunday,
                    'is_holiday': is_holiday
                }
            elif record:
                # Calculate status
                total_secs = record.work_duration.total_seconds() if record.work_duration else 0
                is_late = record.first_in and record.first_in > shift_start
                arrived_after_noon = record.first_in and record.first_in.hour >= 12
                
                # Saturday has 4-hour shift (shift_start + 4 hours), weekdays use full shift_end
                is_saturday = weekday == 5
                if is_saturday:
                    # Saturday shift ends 4 hours after start
                    sat_shift_end = datetime.time(shift_start.hour + 4, shift_start.minute)
                    left_early = record.last_out and record.last_out < sat_shift_end
                else:
                    left_early = record.last_out and record.last_out < shift_end
                
                if total_secs == 0:
                    status = 'absent'
                    summary['leave_days'] += 1
                elif arrived_after_noon or left_early:
                    status = 'yellow'
                    summary['half_days'] += 1
                    if is_late:
                        summary['late_days'] += 1
                elif is_late:
                    status = 'yellow'
                    summary['late_days'] += 1
                    summary['full_days'] += 1
                else:
                    status = 'green'
                    summary['full_days'] += 1
                
                calendar_data[day] = {
                    'record': record,
                    'status': status,
                    'is_sunday': False,
                    'is_holiday': False
                }
            elif day <= current_day:
                calendar_data[day] = {
                    'record': None,
                    'status': 'absent',
                    'is_sunday': False,
                    'is_holiday': False
                }
                summary['leave_days'] += 1
        
        # Calculate total working days = full days + holidays + (half days * 0.5)
        summary['total_working'] = summary['full_days'] + summary['holidays'] + (summary['half_days'] * 0.5)
        
        context = {
            'employee': employee,
            'employee_type': 'In-House',
            'calendar_data': calendar_data,
            'summary': summary,
        }
    
    else:  # Remote employee
        try:
            employee = RemoteEmployee.objects.get(id=employee_id)
        except RemoteEmployee.DoesNotExist:
            return redirect('employee_logout')
        
        records = RemoteCallRecord.objects.filter(
            employee=employee,
            date__year=selected_year,
            date__month=selected_month
        )
        records_dict = {r.date.day: r for r in records}
        
        # Build calendar data
        calendar_data = {}
        summary = {'present_days': 0, 'half_days': 0, 'absent_days': 0, 'total_talk_hours': 0, 'holidays': 0}
        total_talk_seconds = 0
        
        for day in range(1, days_in_month + 1):
            date = datetime.date(selected_year, selected_month, day)
            weekday = date.weekday()
            is_sunday = weekday == 6
            is_holiday = date in holiday_dates
            
            # Only count holidays up to current day
            if (is_sunday or is_holiday) and day <= current_day:
                summary['holidays'] += 1
            
            record = records_dict.get(day)
            
            if is_sunday or is_holiday:
                calendar_data[day] = {
                    'record': None,
                    'status': 'holiday',
                    'is_sunday': is_sunday,
                    'is_holiday': is_holiday
                }
            elif record:
                talk_minutes = int(record.total_talk_duration.total_seconds() / 60) if record.total_talk_duration else 0
                total_talk_seconds += record.total_talk_duration.total_seconds() if record.total_talk_duration else 0
                
                if record.attendance_status == 'present':
                    status = 'green'
                    summary['present_days'] += 1
                elif record.attendance_status == 'half_day':
                    status = 'yellow'
                    summary['half_days'] += 1
                else:
                    status = 'absent'
                    summary['absent_days'] += 1
                
                calendar_data[day] = {
                    'record': record,
                    'status': status,
                    'is_sunday': False,
                    'is_holiday': False,
                    'talk_minutes': talk_minutes,
                    'answered_calls': record.answered_calls
                }
            elif day <= current_day:
                calendar_data[day] = {
                    'record': None,
                    'status': 'absent',
                    'is_sunday': False,
                    'is_holiday': False
                }
                summary['absent_days'] += 1
        
        summary['total_talk_hours'] = round(total_talk_seconds / 3600, 1)
        # Calculate total working days = present days + holidays + (half days * 0.5)
        summary['total_working'] = summary['present_days'] + summary['holidays'] + (summary['half_days'] * 0.5)
        
        context = {
            'employee': employee,
            'employee_type': 'Remote',
            'calendar_data': calendar_data,
            'summary': summary,
        }
    
    # Common context
    context.update({
        'employee_name': employee_name,
        'selected_month': selected_month,
        'selected_year': selected_year,
        'month_name': month_names[selected_month],
        'months': [
            (1, 'January'), (2, 'February'), (3, 'March'), (4, 'April'),
            (5, 'May'), (6, 'June'), (7, 'July'), (8, 'August'),
            (9, 'September'), (10, 'October'), (11, 'November'), (12, 'December')
        ],
        'years': range(2020, 2036),
        'calendar_days': calendar_days,
        'weekdays': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        'days_in_month': days_in_month,
        'current_day': current_day,
        'holiday_days': holiday_days,
    })
    
    return render(request, 'attendance/employee_portal.html', context)


def submit_early_leave_request(request):
    """Handle early leave request submission from employee portal."""
    from .models import EarlyLeaveRequest
    from django.http import JsonResponse
    import datetime
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Invalid request method'})
    
    # Check if employee is logged in
    if 'employee_id' not in request.session:
        return JsonResponse({'success': False, 'error': 'Not logged in'})
    
    employee_id = request.session.get('employee_id')
    employee_type = request.session.get('employee_type')
    
    # Get form data
    leaving_time_str = request.POST.get('leaving_time')
    return_time_str = request.POST.get('return_time')
    destination = request.POST.get('destination', '').strip()
    customer_name = request.POST.get('customer_name', '').strip()
    reason = request.POST.get('reason', '').strip()
    
    # Validate required fields
    if not leaving_time_str or not destination or not customer_name:
        return JsonResponse({'success': False, 'error': 'Please fill in all required fields'})
    
    try:
        leaving_time = datetime.datetime.strptime(leaving_time_str, '%H:%M').time()
        
        return_time = None
        if return_time_str:
            return_time = datetime.datetime.strptime(return_time_str, '%H:%M').time()
            
    except ValueError:
        return JsonResponse({'success': False, 'error': 'Invalid time format'})
    
    # Create the request
    try:
        early_leave = EarlyLeaveRequest(
            request_date=datetime.date.today(),
            leaving_time=leaving_time,
            return_time=return_time,
            destination=destination,
            customer_name=customer_name,
            reason=reason,
            status='pending'
        )
        
        if employee_type == 'inhouse':
            early_leave.employee_id = employee_id
        else:
            early_leave.remote_employee_id = employee_id
        
        early_leave.save()
        
        return JsonResponse({'success': True, 'message': 'Request submitted successfully'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


# ============================================
# Request Approval Endpoints (Admin)
# ============================================

@login_required
@user_passes_test(superuser_required, login_url='/report/')
def get_request_attendance_data(request, request_id):
    """Get attendance data for a pending early leave request."""
    import datetime
    from django.http import JsonResponse
    from .models import EarlyLeaveRequest, AttendanceRecord, RemoteCallRecord
    
    try:
        early_leave = EarlyLeaveRequest.objects.get(id=request_id)
    except EarlyLeaveRequest.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Request not found'})
    
    # Get the request date
    request_date = early_leave.request_date
    
    # Determine employee type and fetch attendance record
    if early_leave.employee:
        # In-house employee
        attendance = AttendanceRecord.objects.filter(
            employee=early_leave.employee,
            date=request_date
        ).first()
        
        if attendance:
            has_data = True
            first_in = attendance.first_in.strftime('%H:%M') if attendance.first_in else ''
            last_out = attendance.last_out.strftime('%H:%M') if attendance.last_out else ''
        else:
            has_data = False
            first_in = ''
            last_out = ''
        
        employee_name = early_leave.employee.name
        employee_type = 'inhouse'
    else:
        # Remote employee - they use call records, not time in/out
        call_record = RemoteCallRecord.objects.filter(
            employee=early_leave.remote_employee,
            date=request_date
        ).first()
        
        has_data = call_record is not None
        first_in = ''  # Remote employees don't have in/out times
        last_out = ''
        employee_name = early_leave.remote_employee.name
        employee_type = 'remote'
    
    return JsonResponse({
        'success': True,
        'has_data': has_data,
        'employee_name': employee_name,
        'employee_type': employee_type,
        'request_date': request_date.strftime('%Y-%m-%d'),
        'first_in': first_in,
        'last_out': last_out,
        'leaving_time': early_leave.leaving_time.strftime('%H:%M'),
        'return_time': early_leave.return_time.strftime('%H:%M') if early_leave.return_time else '',
        'destination': early_leave.destination,
        'customer_name': early_leave.customer_name,
        'reason': early_leave.reason,
    })


@login_required
@user_passes_test(superuser_required, login_url='/report/')
def approve_early_leave(request, request_id):
    """Approve an early leave request and update attendance times."""
    import datetime
    from django.http import JsonResponse
    from django.utils import timezone
    from .models import EarlyLeaveRequest, AttendanceRecord
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'POST required'})
    
    try:
        early_leave = EarlyLeaveRequest.objects.get(id=request_id)
    except EarlyLeaveRequest.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Request not found'})
    
    if early_leave.status != 'pending':
        return JsonResponse({'success': False, 'error': 'Request already processed'})
    
    # Only in-house employees have time updates (remote employees don't have in/out times)
    if early_leave.employee:
        # Get the attendance record
        attendance = AttendanceRecord.objects.filter(
            employee=early_leave.employee,
            date=early_leave.request_date
        ).first()
        
        if not attendance:
            return JsonResponse({'success': False, 'error': 'No biometric data found for this date. Cannot approve yet.'})
        
        # Get new times from request
        new_first_in = request.POST.get('new_first_in', '').strip()
        new_last_out = request.POST.get('new_last_out', '').strip()
        
        try:
            if new_first_in:
                attendance.first_in = datetime.datetime.strptime(new_first_in, '%H:%M').time()
            if new_last_out:
                attendance.last_out = datetime.datetime.strptime(new_last_out, '%H:%M').time()
            
            # Recalculate work duration
            if attendance.first_in and attendance.last_out:
                today = datetime.date.today()
                dt_in = datetime.datetime.combine(today, attendance.first_in)
                dt_out = datetime.datetime.combine(today, attendance.last_out)
                attendance.work_duration = dt_out - dt_in
            
            attendance.save()
        except ValueError:
            return JsonResponse({'success': False, 'error': 'Invalid time format'})
    
    # Mark request as approved
    early_leave.status = 'approved'
    early_leave.reviewed_at = timezone.now()
    early_leave.save()
    
    return JsonResponse({'success': True, 'message': 'Request approved successfully'})


@login_required
@user_passes_test(superuser_required, login_url='/report/')
def decline_early_leave(request, request_id):
    """Decline an early leave request."""
    from django.http import JsonResponse
    from django.utils import timezone
    from .models import EarlyLeaveRequest
    
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'POST required'})
    
    try:
        early_leave = EarlyLeaveRequest.objects.get(id=request_id)
    except EarlyLeaveRequest.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Request not found'})
    
    if early_leave.status != 'pending':
        return JsonResponse({'success': False, 'error': 'Request already processed'})
    
    # Get optional admin notes
    admin_notes = request.POST.get('admin_notes', '').strip()
    
    # Mark request as rejected
    early_leave.status = 'rejected'
    early_leave.admin_notes = admin_notes
    early_leave.reviewed_at = timezone.now()
    early_leave.save()
    
    return JsonResponse({'success': True, 'message': 'Request declined'})
